# -*- coding: utf-8 -*-
"""Smartbridze.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KWIIHNd5lWFbsvdp_n_GbcSpIx2nDig9
"""

#import libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

#Read dataset
df = pd.read_csv('/content/patient_data.csv')
df.head()

df.rename(columns={'C':'Gender'},inplace=True)

df.head()

#handling missing values
df.info()

df.shape

df.isnull().sum()

#converting categorical into numerical value
from sklearn.preprocessing import LabelEncoder
columns = ['Gender', 'Severity', 'History','Patient','TakeMedication','BreathShortness',
             'VisualChanges', 'NoseBleeding', 'ControlledDiet', 'Stages']
label_encoder = LabelEncoder()

for col in columns:
  df[col] = label_encoder.fit_transform(df[col])

df['Stages'].unique()

df['Stages'] = df['Stages'].replace({
    'HYPERTENSIVE CRISI': 'HYPERTENSIVE CRISIS',
    'HYPERTENSION (Stage-2).': 'HYPERTENSION (Stage-2)'
})

df['Stages'].unique()

#2.Exploratory Data analysis
#2.1Descriptive statistical

df.describe()

gender_counts = df['Gender'].value_counts()
#Plotting the pie chart
plt.pie(gender_counts, labels = gender_counts.index, autopct='%1.0f%%', startangle=140)
plt.title("Gender Distribution")
plt.axis("equal")
plt.show()

import matplotlib.pyplot as plt

# Plot frequency of 'Stages'
plt.figure(figsize=(6,6))
df['Stages'].value_counts().plot(kind="bar")
plt.xlabel('Stages')
plt.ylabel('Frequency')
plt.title('Count of Stages')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

plt.figure(figsize=(8, 5))  # Optional: Adjust figure size
sns.countplot(x='TakeMedication', hue='Severity', data=df, palette='viridis')

plt.title('Count Plot of TakeMedication by Severity', fontsize=14)
plt.xlabel('Take Medication', fontsize=12)
plt.ylabel('Count', fontsize=12)
plt.legend(title='Severity')
plt.tight_layout()
plt.show()

# To visualize the relationship between categorical variables, we can use a heatmap of counts.
# First, let's create a pivot table or cross-tabulation of the counts.
age_systolic_counts = df.groupby(['Age', 'Systolic']).size().unstack(fill_value=0)

# Plotting the heatmap
plt.figure(figsize=(10, 6))
sns.heatmap(age_systolic_counts, annot=True, fmt='d', cmap='viridis')
plt.title('Count of Systolic Ranges by Age Group')
plt.xlabel('Systolic Range')
plt.ylabel('Age Group')
plt.show()

# Similarly, for Diastolic
age_diastolic_counts = df.groupby(['Age', 'Diastolic']).size().unstack(fill_value=0)

plt.figure(figsize=(10, 6))
sns.heatmap(age_diastolic_counts, annot=True, fmt='d', cmap='viridis')
plt.title('Count of Diastolic Ranges by Age Group')
plt.xlabel('Diastolic Range')
plt.ylabel('Age Group')
plt.show()

#splitting the data into X and Y
x = df.drop("Stages", axis=1)
x

#splitting the data into X and Y
Y = df["Stages"]
Y

#splitting into training and testing dataset
from sklearn.model_selection import train_test_split

x_train, x_test, y_train, y_test =  train_test_split(x, Y, test_size=0.2, random_state=30)

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report
logistic_regression = LogisticRegression()
logistic_regression.fit(x_train, y_train)
y_pred = logistic_regression.predict(x_test)
acc_lr = accuracy_score(y_test,y_pred)
c_lr = classification_report(y_test,y_pred)
print('Accuracy Score: ',acc_lr)
print(c_lr)

from sklearn.ensemble import RandomForestClassifier
random_forest = RandomForestClassifier()
random_forest.fit(x_train, y_train)
y_pred = random_forest.predict(x_test)
acc_rf = accuracy_score(y_test,y_pred)
c_rf = classification_report(y_test,y_pred)
print('Accuracy Score: ',acc_rf)
print(c_rf)

from sklearn.tree import DecisionTreeClassifier
decision_tree_model = DecisionTreeClassifier()
decision_tree_model.fit(x_train, y_train)
y_pred = decision_tree_model.predict(x_test)
acc_dt = accuracy_score(y_test,y_pred)
c_dt = classification_report (y_test,y_pred)
print('Accuracy Score: ',acc_dt)
print(c_dt)

from sklearn.naive_bayes import GaussianNB
NB = GaussianNB()
NB.fit(x_train, y_train)
y_pred = NB.predict(x_test)
acc_nb = accuracy_score(y_test,y_pred)
c_nb = classification_report (y_test,y_pred)
print('Accuracy Score: ',acc_nb)
print(c_nb)

from sklearn.naive_bayes import MultinomialNB
mNB = MultinomialNB()
mNB.fit(x_train, y_train)
y_pred = NB.predict(x_test)
acc_mnb = accuracy_score(y_test,y_pred)
c_mnb = classification_report(y_test,y_pred)
print('Accuracy Score: ',acc_mnb)
print(c_mnb)



# To make a prediction, the input data needs to have the same format as the training data (after one-hot encoding).
# We need to create a DataFrame with the same columns as x_train and apply one-hot encoding.

# Example input data (replace with your actual input)
input_data = pd.DataFrame({
    'Gender': [0],
    'Age': ['65+'],  # Example age range
    'History': [0],
    'Patient': [2],
    'TakeMedication': [0],
    'Severity': [0],
    'BreathShortness': [1],
    'VisualChanges': [6], # This value seems off based on previous value_counts, consider checking valid values
    'NoseBleeding': [0.0], # This value seems off based on previous value_counts, consider checking valid values
    'Whendiagnoused': ['<1 Year'], # Example time
    'Systolic': ['111 - 120'], # Example systolic range
    'Diastolic': ['81 - 90'], # Example diastolic range
    'ControlledDiet': [0],
    'Stages_encoded': [0] # This column is part of x, but should not be in the input for prediction as it is the target
})

# Drop the target column 'Stages_encoded' from the input data if it exists
if 'Stages_encoded' in input_data.columns:
    input_data = input_data.drop('Stages_encoded', axis=1)


# Identify categorical columns that were one-hot encoded during training
categorical_cols = ['Age', 'Whendiagnoused', 'Systolic', 'Diastolic'] # Add other categorical columns if they were one-hot encoded

# Apply one-hot encoding to the input data
input_data_encoded = pd.get_dummies(input_data, columns=categorical_cols, drop_first=False)

# Reindex the encoded input data to match the columns of x_train.
# This is crucial to ensure the columns are in the same order and missing columns are added with a value of 0.
input_data_encoded = input_data_encoded.reindex(columns=x_train.columns, fill_value=0)


prediction = random_forest.predict(input_data_encoded)
print("Predicted Stage:", prediction[0])

model = pd.DataFrame({
    'Model': ['Logistic Regression', 'Random Forest', 'Decision Tree', 'Naive Bayes', 'Multinomial Naive Bayes'],
    'Accuracy': [acc_lr, acc_rf, acc_dt, acc_nb, acc_mnb]
})

model

#import pickle
#import warnings
#pickle.dump(random_forest,open('model.pkl','wb'))

#import numpy as np
#import pickle
#import pandas as pd
#from flask import Flask, request, render_template

from flask import Flask, request, render_template
import numpy as np
import pandas as pd

@app.route("/predict", methods=["POST"])
def predict():
    # Get values from the form and convert to float
    Gender = float(request.form["Gender"])
    Age = float(request.form["Age"])
    Patient = float(request.form["Patient"])
    Severity = float(request.form["Severity"])
    BreathShortness = float(request.form["BreathShortness"])
    VisualChanges = float(request.form["VisualChanges"])
    Nosebleeding = float(request.form["Nosebleeding"])
    Whendiagnosed = float(request.form["Whendiagnosed"])
    Systolic = float(request.form["Systolic"])
    Diastolic = float(request.form["Diastolic"])
    ControlledDiet = float(request.form["ControlledDiet"])

    # Create feature array
    features_values = np.array([[Gender, Age, Patient, Severity, BreathShortness,
                                 VisualChanges, Nosebleeding, Whendiagnosed,
                                 Systolic, Diastolic, ControlledDiet]])

    # Create DataFrame with correct column names
    feature_columns = ["Gender", "Age", "Patient", "Severity", "BreathShortness",
                       "VisualChanges", "Nosebleeding", "Whendiagnosed",
                       "Systolic", "Diastolic", "ControlledDiet"]

    df = pd.DataFrame(features_values, columns=feature_columns)

    # Debug print
    print(df)

    # Make prediction
    prediction = model.predict(df)
    print("Raw prediction:", prediction[0])

    # Map prediction to stage
    if prediction[0] == 0:
        result = "NORMAL"
    elif prediction[0] == 1:
        result = "HYPERTENSION (Stage-1)"
    elif prediction[0] == 2:
        result = "HYPERTENSION (Stage-2)"
    else:
        result = "HYPERTENSIVE CRISIS"

    print(result)

    # Return result to template
    return render_template("predict.html", prediction_text="Your Blood Pressure stage is: " + result)